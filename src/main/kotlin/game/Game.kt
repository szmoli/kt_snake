package game

import utility.Vector3
import utility.View
import kotlin.collections.List
import kotlin.math.max
import kotlin.random.Random

/**
 * Constructs a game class, which manages the game's logic.
 */
class Game(val worldSize: Vector3, val obstacleChance: Float) {
    /**
     * The snake stars from the middle of the world.
     */
    val snake = Snake(Vector3(worldSize.x / 2, worldSize.y / 2, 1))

    /**
     * The obstacles are generated outside a small circle around the world center.
     */
    val obstacles: List<Obstacle> by lazy {
        List<Obstacle?>(worldSize.x * worldSize.y) { index ->
            val position = View.worldPosition(index)
            val center = Vector3(worldSize.x / 2, worldSize.y / 2, 1)
            val middleCirclePoint = ((position.x - center.x) * (position.x - center.x)) + ((position.y - center.y) * (position.y - center.y));
//            val biggerDimension = max(worldSize.x, worldSize.y)
            val circleRadius = 5
            println("$middleCirclePoint vs $circleRadius")
            val obstacle = Obstacle(position)
            obstacle.takeIf {
                val outsideMiddleCircle = middleCirclePoint > circleRadius
                val shouldSpawn = Random.nextFloat() < obstacleChance
                println("$outsideMiddleCircle $shouldSpawn")
                outsideMiddleCircle && shouldSpawn
            }
        }.filterNotNull()
    }

    /**
     * The food can't be in the center of the world. New food will be generated by newFood()
     * @see generateFood
     */
    var food = generateFood()

    /**
     *  Starts the game.
     */
    fun startGame() {

    }

    /**
     *  Ends the game.
     */
    fun endGame() {

    }

    /**
     *  Executes game logic and advances the game state.
     */
    fun tick() {

    }

    /**
     * Generates a piece new food that's not in the center of the world and which isn't overlapping of existing obstacles.
     * @return The new food
     */
    fun generateFood(): Food {
        var x: Int
        var y: Int
        var food: Food
        do {
            x = Random.nextInt(worldSize.x)
            y = Random.nextInt(worldSize.y)
            food = Food(Vector3(x, y, 1))
        } while ((x == worldSize.x / 2 && y == worldSize.y / 2) || obstacles.any { it.checkCollision(food) && snake.checkCollision(food) }) // Check for the world center and if there's already an obstacle or if the snake is there

        return food
    }

    /**
     * Returns the GameObject at the specified position.
     * @param position World position
     * @return Null if there is no GameObject at the position, the GameObject itself otherwise
     * @see GameObject
     */
    fun objectAt(position: Vector3): GameObject? {
        if (Vector3.equals(food.position, position)) {
            return food
        }

        for (obstacle in obstacles) {
            if (Vector3.equals(obstacle.position, position)) {
                return obstacle
            }
        }

        if (snake.checkCollision(position)) {
            return snake
        }

        return null
    }
}