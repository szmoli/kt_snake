package game

import utility.IViewable
import utility.Vector3
import utility.View
import utility.View.Companion.SIZE
import utility.View.Companion.worldPosition
import kotlin.collections.List
import kotlin.math.max
import kotlin.random.Random

/**
 * Constructs a game class, which manages the game's logic.
 */
class Game(val worldSize: Vector3, val obstacleChance: Float) : IViewable {
    /**
     * The snake stars from the middle of the world.
     */
    val snake = Snake(Vector3(worldSize.x / 2, worldSize.y / 2, 1))

    /**
     * The obstacles are generated outside a small circle around the world center.
     */
    val obstacles: List<Obstacle> by lazy {
        List<Obstacle?>(worldSize.x * worldSize.y) { index ->
            val position = View.worldPosition(index)
            val center = Vector3(worldSize.x / 2, worldSize.y / 2, 1)
            val middleCirclePoint =
                ((position.x - center.x) * (position.x - center.x)) + ((position.y - center.y) * (position.y - center.y));
            val circleRadius = 5
            val obstacle = Obstacle(position, Vector3(Random.nextInt(1, 4), Random.nextInt(1, 4), 0))

            obstacle.takeIf {
                val outsideMiddleCircle = middleCirclePoint > circleRadius
                val shouldSpawn = Random.nextFloat() < obstacleChance
                val isBorder =
                    obstacle.position.x == 0 || obstacle.position.x == worldSize.x - 1 || obstacle.position.y == 0 || obstacle.position.y == worldSize.y - 1

                (outsideMiddleCircle && shouldSpawn) || isBorder
            }
        }.filterNotNull()
    }

    /**
     * The food can't be in the center of the world. New food will be generated by newFood()
     * @see generateFood
     */
    var food = generateFood()

    /**
     *  Starts the game.
     */
    fun startGame() {

    }

    /**
     *  Ends the game.
     */
    fun endGame() {

    }

    /**
     *  Executes game logic and advances the game state.
     */
    fun tick() {

    }

    /**
     * Generates a piece new food that's not in the center of the world and which isn't overlapping of existing obstacles.
     * @return The new food
     */
    fun generateFood(): Food {
        var x: Int
        var y: Int
        var food: Food
        do {
            x = Random.nextInt(worldSize.x)
            y = Random.nextInt(worldSize.y)
            food = Food(Vector3(x, y, 1))
        } while ((x == worldSize.x / 2 && y == worldSize.y / 2) || obstacles.any {
                it.checkCollision(food) && snake.checkCollision(
                    food
                )
            }) // Check for the world center and if there's already an obstacle or if the snake is there

        return food
    }

    /**
     * Returns the GameObject at the specified position.
     * @param position World position
     * @return Null if there is no GameObject at the position, the GameObject itself otherwise
     * @see GameObject
     */
    fun objectAt(position: Vector3): GameObject? {
        if (Vector3.equals(food.position, position)) {
            return food
        }

        for (obstacle in obstacles) {
            if (obstacle.checkCollision(position)) {
                return obstacle
            }
        }

        if (snake.checkCollision(position)) {
            return snake
        }

        return null
    }

    override fun viewBufferData(bufferSize: Int): CharArray {
        val bufferData: CharArray = CharArray(bufferSize) {
            val worldPosition = worldPosition(it)
            val gameObject = objectAt(worldPosition)
            gameObject?.tile(worldPosition) ?: ' '
        }

        return bufferData
    }
}
